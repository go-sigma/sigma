// Code generated by go-enum DO NOT EDIT.
// Version: 0.6.0
// Revision: 919e61c0174b91303753ee3898569a01abb32c97
// Build Date: 2023-12-18T15:54:43Z
// Built By: goreleaser

package enums

import (
	"database/sql/driver"
	"errors"
	"fmt"
)

const (
	// ArtifactTypeImage is a ArtifactType of type Image.
	ArtifactTypeImage ArtifactType = "Image"
	// ArtifactTypeImageIndex is a ArtifactType of type ImageIndex.
	ArtifactTypeImageIndex ArtifactType = "ImageIndex"
	// ArtifactTypeChart is a ArtifactType of type Chart.
	ArtifactTypeChart ArtifactType = "Chart"
	// ArtifactTypeCnab is a ArtifactType of type Cnab.
	ArtifactTypeCnab ArtifactType = "Cnab"
	// ArtifactTypeWasm is a ArtifactType of type Wasm.
	ArtifactTypeWasm ArtifactType = "Wasm"
	// ArtifactTypeProvenance is a ArtifactType of type Provenance.
	ArtifactTypeProvenance ArtifactType = "Provenance"
	// ArtifactTypeCosign is a ArtifactType of type Cosign.
	ArtifactTypeCosign ArtifactType = "Cosign"
	// ArtifactTypeSif is a ArtifactType of type Sif.
	ArtifactTypeSif ArtifactType = "Sif"
	// ArtifactTypeUnknown is a ArtifactType of type Unknown.
	ArtifactTypeUnknown ArtifactType = "Unknown"
)

var ErrInvalidArtifactType = errors.New("not a valid ArtifactType")

// String implements the Stringer interface.
func (x ArtifactType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArtifactType) IsValid() bool {
	_, err := ParseArtifactType(string(x))
	return err == nil
}

var _ArtifactTypeValue = map[string]ArtifactType{
	"Image":      ArtifactTypeImage,
	"ImageIndex": ArtifactTypeImageIndex,
	"Chart":      ArtifactTypeChart,
	"Cnab":       ArtifactTypeCnab,
	"Wasm":       ArtifactTypeWasm,
	"Provenance": ArtifactTypeProvenance,
	"Cosign":     ArtifactTypeCosign,
	"Sif":        ArtifactTypeSif,
	"Unknown":    ArtifactTypeUnknown,
}

// ParseArtifactType attempts to convert a string to a ArtifactType.
func ParseArtifactType(name string) (ArtifactType, error) {
	if x, ok := _ArtifactTypeValue[name]; ok {
		return x, nil
	}
	return ArtifactType(""), fmt.Errorf("%s is %w", name, ErrInvalidArtifactType)
}

// MustParseArtifactType converts a string to a ArtifactType, and panics if is not valid.
func MustParseArtifactType(name string) ArtifactType {
	val, err := ParseArtifactType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errArtifactTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ArtifactType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ArtifactType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseArtifactType(v)
	case []byte:
		*x, err = ParseArtifactType(string(v))
	case ArtifactType:
		*x = v
	case *ArtifactType:
		if v == nil {
			return errArtifactTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errArtifactTypeNilPtr
		}
		*x, err = ParseArtifactType(*v)
	default:
		return errors.New("invalid type for ArtifactType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x ArtifactType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// AuditActionCreate is a AuditAction of type Create.
	AuditActionCreate AuditAction = "Create"
	// AuditActionUpdate is a AuditAction of type Update.
	AuditActionUpdate AuditAction = "Update"
	// AuditActionDelete is a AuditAction of type Delete.
	AuditActionDelete AuditAction = "Delete"
	// AuditActionPull is a AuditAction of type Pull.
	AuditActionPull AuditAction = "Pull"
	// AuditActionPush is a AuditAction of type Push.
	AuditActionPush AuditAction = "Push"
)

var ErrInvalidAuditAction = errors.New("not a valid AuditAction")

// String implements the Stringer interface.
func (x AuditAction) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AuditAction) IsValid() bool {
	_, err := ParseAuditAction(string(x))
	return err == nil
}

var _AuditActionValue = map[string]AuditAction{
	"Create": AuditActionCreate,
	"Update": AuditActionUpdate,
	"Delete": AuditActionDelete,
	"Pull":   AuditActionPull,
	"Push":   AuditActionPush,
}

// ParseAuditAction attempts to convert a string to a AuditAction.
func ParseAuditAction(name string) (AuditAction, error) {
	if x, ok := _AuditActionValue[name]; ok {
		return x, nil
	}
	return AuditAction(""), fmt.Errorf("%s is %w", name, ErrInvalidAuditAction)
}

// MustParseAuditAction converts a string to a AuditAction, and panics if is not valid.
func MustParseAuditAction(name string) AuditAction {
	val, err := ParseAuditAction(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errAuditActionNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *AuditAction) Scan(value interface{}) (err error) {
	if value == nil {
		*x = AuditAction("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseAuditAction(v)
	case []byte:
		*x, err = ParseAuditAction(string(v))
	case AuditAction:
		*x = v
	case *AuditAction:
		if v == nil {
			return errAuditActionNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errAuditActionNilPtr
		}
		*x, err = ParseAuditAction(*v)
	default:
		return errors.New("invalid type for AuditAction")
	}

	return
}

// Value implements the driver Valuer interface.
func (x AuditAction) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// AuditResourceTypeNamespace is a AuditResourceType of type Namespace.
	AuditResourceTypeNamespace AuditResourceType = "Namespace"
	// AuditResourceTypeNamespaceMember is a AuditResourceType of type NamespaceMember.
	AuditResourceTypeNamespaceMember AuditResourceType = "NamespaceMember"
	// AuditResourceTypeRepository is a AuditResourceType of type Repository.
	AuditResourceTypeRepository AuditResourceType = "Repository"
	// AuditResourceTypeTag is a AuditResourceType of type Tag.
	AuditResourceTypeTag AuditResourceType = "Tag"
	// AuditResourceTypeWebhook is a AuditResourceType of type Webhook.
	AuditResourceTypeWebhook AuditResourceType = "Webhook"
	// AuditResourceTypeBuilder is a AuditResourceType of type Builder.
	AuditResourceTypeBuilder AuditResourceType = "Builder"
)

var ErrInvalidAuditResourceType = errors.New("not a valid AuditResourceType")

// String implements the Stringer interface.
func (x AuditResourceType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AuditResourceType) IsValid() bool {
	_, err := ParseAuditResourceType(string(x))
	return err == nil
}

var _AuditResourceTypeValue = map[string]AuditResourceType{
	"Namespace":       AuditResourceTypeNamespace,
	"NamespaceMember": AuditResourceTypeNamespaceMember,
	"Repository":      AuditResourceTypeRepository,
	"Tag":             AuditResourceTypeTag,
	"Webhook":         AuditResourceTypeWebhook,
	"Builder":         AuditResourceTypeBuilder,
}

// ParseAuditResourceType attempts to convert a string to a AuditResourceType.
func ParseAuditResourceType(name string) (AuditResourceType, error) {
	if x, ok := _AuditResourceTypeValue[name]; ok {
		return x, nil
	}
	return AuditResourceType(""), fmt.Errorf("%s is %w", name, ErrInvalidAuditResourceType)
}

// MustParseAuditResourceType converts a string to a AuditResourceType, and panics if is not valid.
func MustParseAuditResourceType(name string) AuditResourceType {
	val, err := ParseAuditResourceType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errAuditResourceTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *AuditResourceType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = AuditResourceType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseAuditResourceType(v)
	case []byte:
		*x, err = ParseAuditResourceType(string(v))
	case AuditResourceType:
		*x = v
	case *AuditResourceType:
		if v == nil {
			return errAuditResourceTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errAuditResourceTypeNilPtr
		}
		*x, err = ParseAuditResourceType(*v)
	default:
		return errors.New("invalid type for AuditResourceType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x AuditResourceType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// AuthRead is a Auth of type Read.
	AuthRead Auth = "Read"
	// AuthManage is a Auth of type Manage.
	AuthManage Auth = "Manage"
	// AuthAdmin is a Auth of type Admin.
	AuthAdmin Auth = "Admin"
)

var ErrInvalidAuth = errors.New("not a valid Auth")

// String implements the Stringer interface.
func (x Auth) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Auth) IsValid() bool {
	_, err := ParseAuth(string(x))
	return err == nil
}

var _AuthValue = map[string]Auth{
	"Read":   AuthRead,
	"Manage": AuthManage,
	"Admin":  AuthAdmin,
}

// ParseAuth attempts to convert a string to a Auth.
func ParseAuth(name string) (Auth, error) {
	if x, ok := _AuthValue[name]; ok {
		return x, nil
	}
	return Auth(""), fmt.Errorf("%s is %w", name, ErrInvalidAuth)
}

// MustParseAuth converts a string to a Auth, and panics if is not valid.
func MustParseAuth(name string) Auth {
	val, err := ParseAuth(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errAuthNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Auth) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Auth("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseAuth(v)
	case []byte:
		*x, err = ParseAuth(string(v))
	case Auth:
		*x = v
	case *Auth:
		if v == nil {
			return errAuthNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errAuthNilPtr
		}
		*x, err = ParseAuth(*v)
	default:
		return errors.New("invalid type for Auth")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Auth) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// BuildStatusSuccess is a BuildStatus of type Success.
	BuildStatusSuccess BuildStatus = "Success"
	// BuildStatusFailed is a BuildStatus of type Failed.
	BuildStatusFailed BuildStatus = "Failed"
	// BuildStatusPending is a BuildStatus of type Pending.
	BuildStatusPending BuildStatus = "Pending"
	// BuildStatusScheduling is a BuildStatus of type Scheduling.
	BuildStatusScheduling BuildStatus = "Scheduling"
	// BuildStatusBuilding is a BuildStatus of type Building.
	BuildStatusBuilding BuildStatus = "Building"
	// BuildStatusStopping is a BuildStatus of type Stopping.
	BuildStatusStopping BuildStatus = "Stopping"
	// BuildStatusStopped is a BuildStatus of type Stopped.
	BuildStatusStopped BuildStatus = "Stopped"
)

var ErrInvalidBuildStatus = errors.New("not a valid BuildStatus")

// String implements the Stringer interface.
func (x BuildStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BuildStatus) IsValid() bool {
	_, err := ParseBuildStatus(string(x))
	return err == nil
}

var _BuildStatusValue = map[string]BuildStatus{
	"Success":    BuildStatusSuccess,
	"Failed":     BuildStatusFailed,
	"Pending":    BuildStatusPending,
	"Scheduling": BuildStatusScheduling,
	"Building":   BuildStatusBuilding,
	"Stopping":   BuildStatusStopping,
	"Stopped":    BuildStatusStopped,
}

// ParseBuildStatus attempts to convert a string to a BuildStatus.
func ParseBuildStatus(name string) (BuildStatus, error) {
	if x, ok := _BuildStatusValue[name]; ok {
		return x, nil
	}
	return BuildStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidBuildStatus)
}

// MustParseBuildStatus converts a string to a BuildStatus, and panics if is not valid.
func MustParseBuildStatus(name string) BuildStatus {
	val, err := ParseBuildStatus(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errBuildStatusNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *BuildStatus) Scan(value interface{}) (err error) {
	if value == nil {
		*x = BuildStatus("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseBuildStatus(v)
	case []byte:
		*x, err = ParseBuildStatus(string(v))
	case BuildStatus:
		*x = v
	case *BuildStatus:
		if v == nil {
			return errBuildStatusNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errBuildStatusNilPtr
		}
		*x, err = ParseBuildStatus(*v)
	default:
		return errors.New("invalid type for BuildStatus")
	}

	return
}

// Value implements the driver Valuer interface.
func (x BuildStatus) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// BuilderSourceDockerfile is a BuilderSource of type Dockerfile.
	BuilderSourceDockerfile BuilderSource = "Dockerfile"
	// BuilderSourceCodeRepository is a BuilderSource of type CodeRepository.
	BuilderSourceCodeRepository BuilderSource = "CodeRepository"
	// BuilderSourceSelfCodeRepository is a BuilderSource of type SelfCodeRepository.
	BuilderSourceSelfCodeRepository BuilderSource = "SelfCodeRepository"
)

var ErrInvalidBuilderSource = errors.New("not a valid BuilderSource")

// String implements the Stringer interface.
func (x BuilderSource) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BuilderSource) IsValid() bool {
	_, err := ParseBuilderSource(string(x))
	return err == nil
}

var _BuilderSourceValue = map[string]BuilderSource{
	"Dockerfile":         BuilderSourceDockerfile,
	"CodeRepository":     BuilderSourceCodeRepository,
	"SelfCodeRepository": BuilderSourceSelfCodeRepository,
}

// ParseBuilderSource attempts to convert a string to a BuilderSource.
func ParseBuilderSource(name string) (BuilderSource, error) {
	if x, ok := _BuilderSourceValue[name]; ok {
		return x, nil
	}
	return BuilderSource(""), fmt.Errorf("%s is %w", name, ErrInvalidBuilderSource)
}

// MustParseBuilderSource converts a string to a BuilderSource, and panics if is not valid.
func MustParseBuilderSource(name string) BuilderSource {
	val, err := ParseBuilderSource(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errBuilderSourceNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *BuilderSource) Scan(value interface{}) (err error) {
	if value == nil {
		*x = BuilderSource("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseBuilderSource(v)
	case []byte:
		*x, err = ParseBuilderSource(string(v))
	case BuilderSource:
		*x = v
	case *BuilderSource:
		if v == nil {
			return errBuilderSourceNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errBuilderSourceNilPtr
		}
		*x, err = ParseBuilderSource(*v)
	default:
		return errors.New("invalid type for BuilderSource")
	}

	return
}

// Value implements the driver Valuer interface.
func (x BuilderSource) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// BuilderTypeDocker is a BuilderType of type docker.
	BuilderTypeDocker BuilderType = "docker"
	// BuilderTypeKubernetes is a BuilderType of type kubernetes.
	BuilderTypeKubernetes BuilderType = "kubernetes"
)

var ErrInvalidBuilderType = errors.New("not a valid BuilderType")

// String implements the Stringer interface.
func (x BuilderType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BuilderType) IsValid() bool {
	_, err := ParseBuilderType(string(x))
	return err == nil
}

var _BuilderTypeValue = map[string]BuilderType{
	"docker":     BuilderTypeDocker,
	"kubernetes": BuilderTypeKubernetes,
}

// ParseBuilderType attempts to convert a string to a BuilderType.
func ParseBuilderType(name string) (BuilderType, error) {
	if x, ok := _BuilderTypeValue[name]; ok {
		return x, nil
	}
	return BuilderType(""), fmt.Errorf("%s is %w", name, ErrInvalidBuilderType)
}

// MustParseBuilderType converts a string to a BuilderType, and panics if is not valid.
func MustParseBuilderType(name string) BuilderType {
	val, err := ParseBuilderType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errBuilderTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *BuilderType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = BuilderType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseBuilderType(v)
	case []byte:
		*x, err = ParseBuilderType(string(v))
	case BuilderType:
		*x = v
	case *BuilderType:
		if v == nil {
			return errBuilderTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errBuilderTypeNilPtr
		}
		*x, err = ParseBuilderType(*v)
	default:
		return errors.New("invalid type for BuilderType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x BuilderType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// CacherTypeInmemory is a CacherType of type inmemory.
	CacherTypeInmemory CacherType = "inmemory"
	// CacherTypeRedis is a CacherType of type redis.
	CacherTypeRedis CacherType = "redis"
	// CacherTypeBadger is a CacherType of type badger.
	CacherTypeBadger CacherType = "badger"
)

var ErrInvalidCacherType = errors.New("not a valid CacherType")

// String implements the Stringer interface.
func (x CacherType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CacherType) IsValid() bool {
	_, err := ParseCacherType(string(x))
	return err == nil
}

var _CacherTypeValue = map[string]CacherType{
	"inmemory": CacherTypeInmemory,
	"redis":    CacherTypeRedis,
	"badger":   CacherTypeBadger,
}

// ParseCacherType attempts to convert a string to a CacherType.
func ParseCacherType(name string) (CacherType, error) {
	if x, ok := _CacherTypeValue[name]; ok {
		return x, nil
	}
	return CacherType(""), fmt.Errorf("%s is %w", name, ErrInvalidCacherType)
}

// MustParseCacherType converts a string to a CacherType, and panics if is not valid.
func MustParseCacherType(name string) CacherType {
	val, err := ParseCacherType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errCacherTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *CacherType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = CacherType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseCacherType(v)
	case []byte:
		*x, err = ParseCacherType(string(v))
	case CacherType:
		*x = v
	case *CacherType:
		if v == nil {
			return errCacherTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errCacherTypeNilPtr
		}
		*x, err = ParseCacherType(*v)
	default:
		return errors.New("invalid type for CacherType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x CacherType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// DaemonVulnerability is a Daemon of type Vulnerability.
	DaemonVulnerability Daemon = "Vulnerability"
	// DaemonSbom is a Daemon of type Sbom.
	DaemonSbom Daemon = "Sbom"
	// DaemonGc is a Daemon of type Gc.
	DaemonGc Daemon = "Gc"
	// DaemonGcRepository is a Daemon of type GcRepository.
	DaemonGcRepository Daemon = "GcRepository"
	// DaemonGcArtifact is a Daemon of type GcArtifact.
	DaemonGcArtifact Daemon = "GcArtifact"
	// DaemonGcBlob is a Daemon of type GcBlob.
	DaemonGcBlob Daemon = "GcBlob"
	// DaemonGcTag is a Daemon of type GcTag.
	DaemonGcTag Daemon = "GcTag"
	// DaemonWebhook is a Daemon of type Webhook.
	DaemonWebhook Daemon = "Webhook"
	// DaemonBuilder is a Daemon of type Builder.
	DaemonBuilder Daemon = "Builder"
	// DaemonCodeRepository is a Daemon of type CodeRepository.
	DaemonCodeRepository Daemon = "CodeRepository"
	// DaemonTagPushed is a Daemon of type TagPushed.
	DaemonTagPushed Daemon = "TagPushed"
	// DaemonArtifactPushed is a Daemon of type ArtifactPushed.
	DaemonArtifactPushed Daemon = "ArtifactPushed"
)

var ErrInvalidDaemon = errors.New("not a valid Daemon")

// String implements the Stringer interface.
func (x Daemon) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Daemon) IsValid() bool {
	_, err := ParseDaemon(string(x))
	return err == nil
}

var _DaemonValue = map[string]Daemon{
	"Vulnerability":  DaemonVulnerability,
	"Sbom":           DaemonSbom,
	"Gc":             DaemonGc,
	"GcRepository":   DaemonGcRepository,
	"GcArtifact":     DaemonGcArtifact,
	"GcBlob":         DaemonGcBlob,
	"GcTag":          DaemonGcTag,
	"Webhook":        DaemonWebhook,
	"Builder":        DaemonBuilder,
	"CodeRepository": DaemonCodeRepository,
	"TagPushed":      DaemonTagPushed,
	"ArtifactPushed": DaemonArtifactPushed,
}

// ParseDaemon attempts to convert a string to a Daemon.
func ParseDaemon(name string) (Daemon, error) {
	if x, ok := _DaemonValue[name]; ok {
		return x, nil
	}
	return Daemon(""), fmt.Errorf("%s is %w", name, ErrInvalidDaemon)
}

// MustParseDaemon converts a string to a Daemon, and panics if is not valid.
func MustParseDaemon(name string) Daemon {
	val, err := ParseDaemon(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errDaemonNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Daemon) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Daemon("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseDaemon(v)
	case []byte:
		*x, err = ParseDaemon(string(v))
	case Daemon:
		*x = v
	case *Daemon:
		if v == nil {
			return errDaemonNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errDaemonNilPtr
		}
		*x, err = ParseDaemon(*v)
	default:
		return errors.New("invalid type for Daemon")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Daemon) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// DaemonBuilderActionStart is a DaemonBuilderAction of type Start.
	DaemonBuilderActionStart DaemonBuilderAction = "Start"
	// DaemonBuilderActionRestart is a DaemonBuilderAction of type Restart.
	DaemonBuilderActionRestart DaemonBuilderAction = "Restart"
	// DaemonBuilderActionStop is a DaemonBuilderAction of type Stop.
	DaemonBuilderActionStop DaemonBuilderAction = "Stop"
)

var ErrInvalidDaemonBuilderAction = errors.New("not a valid DaemonBuilderAction")

// String implements the Stringer interface.
func (x DaemonBuilderAction) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DaemonBuilderAction) IsValid() bool {
	_, err := ParseDaemonBuilderAction(string(x))
	return err == nil
}

var _DaemonBuilderActionValue = map[string]DaemonBuilderAction{
	"Start":   DaemonBuilderActionStart,
	"Restart": DaemonBuilderActionRestart,
	"Stop":    DaemonBuilderActionStop,
}

// ParseDaemonBuilderAction attempts to convert a string to a DaemonBuilderAction.
func ParseDaemonBuilderAction(name string) (DaemonBuilderAction, error) {
	if x, ok := _DaemonBuilderActionValue[name]; ok {
		return x, nil
	}
	return DaemonBuilderAction(""), fmt.Errorf("%s is %w", name, ErrInvalidDaemonBuilderAction)
}

// MustParseDaemonBuilderAction converts a string to a DaemonBuilderAction, and panics if is not valid.
func MustParseDaemonBuilderAction(name string) DaemonBuilderAction {
	val, err := ParseDaemonBuilderAction(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errDaemonBuilderActionNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *DaemonBuilderAction) Scan(value interface{}) (err error) {
	if value == nil {
		*x = DaemonBuilderAction("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseDaemonBuilderAction(v)
	case []byte:
		*x, err = ParseDaemonBuilderAction(string(v))
	case DaemonBuilderAction:
		*x = v
	case *DaemonBuilderAction:
		if v == nil {
			return errDaemonBuilderActionNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errDaemonBuilderActionNilPtr
		}
		*x, err = ParseDaemonBuilderAction(*v)
	default:
		return errors.New("invalid type for DaemonBuilderAction")
	}

	return
}

// Value implements the driver Valuer interface.
func (x DaemonBuilderAction) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// DatabasePostgresql is a Database of type postgresql.
	DatabasePostgresql Database = "postgresql"
	// DatabaseMysql is a Database of type mysql.
	DatabaseMysql Database = "mysql"
	// DatabaseSqlite3 is a Database of type sqlite3.
	DatabaseSqlite3 Database = "sqlite3"
)

var ErrInvalidDatabase = errors.New("not a valid Database")

// String implements the Stringer interface.
func (x Database) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Database) IsValid() bool {
	_, err := ParseDatabase(string(x))
	return err == nil
}

var _DatabaseValue = map[string]Database{
	"postgresql": DatabasePostgresql,
	"mysql":      DatabaseMysql,
	"sqlite3":    DatabaseSqlite3,
}

// ParseDatabase attempts to convert a string to a Database.
func ParseDatabase(name string) (Database, error) {
	if x, ok := _DatabaseValue[name]; ok {
		return x, nil
	}
	return Database(""), fmt.Errorf("%s is %w", name, ErrInvalidDatabase)
}

// MustParseDatabase converts a string to a Database, and panics if is not valid.
func MustParseDatabase(name string) Database {
	val, err := ParseDatabase(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errDatabaseNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Database) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Database("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseDatabase(v)
	case []byte:
		*x, err = ParseDatabase(string(v))
	case Database:
		*x = v
	case *Database:
		if v == nil {
			return errDatabaseNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errDatabaseNilPtr
		}
		*x, err = ParseDatabase(*v)
	default:
		return errors.New("invalid type for Database")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Database) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// DeploySingle is a Deploy of type single.
	DeploySingle Deploy = "single"
	// DeployReplica is a Deploy of type replica.
	DeployReplica Deploy = "replica"
)

var ErrInvalidDeploy = errors.New("not a valid Deploy")

// String implements the Stringer interface.
func (x Deploy) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Deploy) IsValid() bool {
	_, err := ParseDeploy(string(x))
	return err == nil
}

var _DeployValue = map[string]Deploy{
	"single":  DeploySingle,
	"replica": DeployReplica,
}

// ParseDeploy attempts to convert a string to a Deploy.
func ParseDeploy(name string) (Deploy, error) {
	if x, ok := _DeployValue[name]; ok {
		return x, nil
	}
	return Deploy(""), fmt.Errorf("%s is %w", name, ErrInvalidDeploy)
}

// MustParseDeploy converts a string to a Deploy, and panics if is not valid.
func MustParseDeploy(name string) Deploy {
	val, err := ParseDeploy(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errDeployNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Deploy) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Deploy("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseDeploy(v)
	case []byte:
		*x, err = ParseDeploy(string(v))
	case Deploy:
		*x = v
	case *Deploy:
		if v == nil {
			return errDeployNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errDeployNilPtr
		}
		*x, err = ParseDeploy(*v)
	default:
		return errors.New("invalid type for Deploy")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Deploy) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// GcRecordStatusSuccess is a GcRecordStatus of type Success.
	GcRecordStatusSuccess GcRecordStatus = "Success"
	// GcRecordStatusFailed is a GcRecordStatus of type Failed.
	GcRecordStatusFailed GcRecordStatus = "Failed"
)

var ErrInvalidGcRecordStatus = errors.New("not a valid GcRecordStatus")

// String implements the Stringer interface.
func (x GcRecordStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x GcRecordStatus) IsValid() bool {
	_, err := ParseGcRecordStatus(string(x))
	return err == nil
}

var _GcRecordStatusValue = map[string]GcRecordStatus{
	"Success": GcRecordStatusSuccess,
	"Failed":  GcRecordStatusFailed,
}

// ParseGcRecordStatus attempts to convert a string to a GcRecordStatus.
func ParseGcRecordStatus(name string) (GcRecordStatus, error) {
	if x, ok := _GcRecordStatusValue[name]; ok {
		return x, nil
	}
	return GcRecordStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidGcRecordStatus)
}

// MustParseGcRecordStatus converts a string to a GcRecordStatus, and panics if is not valid.
func MustParseGcRecordStatus(name string) GcRecordStatus {
	val, err := ParseGcRecordStatus(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errGcRecordStatusNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *GcRecordStatus) Scan(value interface{}) (err error) {
	if value == nil {
		*x = GcRecordStatus("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseGcRecordStatus(v)
	case []byte:
		*x, err = ParseGcRecordStatus(string(v))
	case GcRecordStatus:
		*x = v
	case *GcRecordStatus:
		if v == nil {
			return errGcRecordStatusNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errGcRecordStatusNilPtr
		}
		*x, err = ParseGcRecordStatus(*v)
	default:
		return errors.New("invalid type for GcRecordStatus")
	}

	return
}

// Value implements the driver Valuer interface.
func (x GcRecordStatus) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// GcTargetBlobsAndArtifacts is a GcTarget of type blobsAndArtifacts.
	GcTargetBlobsAndArtifacts GcTarget = "blobsAndArtifacts"
	// GcTargetArtifacts is a GcTarget of type artifacts.
	GcTargetArtifacts GcTarget = "artifacts"
)

var ErrInvalidGcTarget = errors.New("not a valid GcTarget")

// String implements the Stringer interface.
func (x GcTarget) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x GcTarget) IsValid() bool {
	_, err := ParseGcTarget(string(x))
	return err == nil
}

var _GcTargetValue = map[string]GcTarget{
	"blobsAndArtifacts": GcTargetBlobsAndArtifacts,
	"artifacts":         GcTargetArtifacts,
}

// ParseGcTarget attempts to convert a string to a GcTarget.
func ParseGcTarget(name string) (GcTarget, error) {
	if x, ok := _GcTargetValue[name]; ok {
		return x, nil
	}
	return GcTarget(""), fmt.Errorf("%s is %w", name, ErrInvalidGcTarget)
}

// MustParseGcTarget converts a string to a GcTarget, and panics if is not valid.
func MustParseGcTarget(name string) GcTarget {
	val, err := ParseGcTarget(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errGcTargetNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *GcTarget) Scan(value interface{}) (err error) {
	if value == nil {
		*x = GcTarget("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseGcTarget(v)
	case []byte:
		*x, err = ParseGcTarget(string(v))
	case GcTarget:
		*x = v
	case *GcTarget:
		if v == nil {
			return errGcTargetNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errGcTargetNilPtr
		}
		*x, err = ParseGcTarget(*v)
	default:
		return errors.New("invalid type for GcTarget")
	}

	return
}

// Value implements the driver Valuer interface.
func (x GcTarget) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// LockerTypeRedis is a LockerType of type redis.
	LockerTypeRedis LockerType = "redis"
	// LockerTypeBadger is a LockerType of type badger.
	LockerTypeBadger LockerType = "badger"
)

var ErrInvalidLockerType = errors.New("not a valid LockerType")

// String implements the Stringer interface.
func (x LockerType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LockerType) IsValid() bool {
	_, err := ParseLockerType(string(x))
	return err == nil
}

var _LockerTypeValue = map[string]LockerType{
	"redis":  LockerTypeRedis,
	"badger": LockerTypeBadger,
}

// ParseLockerType attempts to convert a string to a LockerType.
func ParseLockerType(name string) (LockerType, error) {
	if x, ok := _LockerTypeValue[name]; ok {
		return x, nil
	}
	return LockerType(""), fmt.Errorf("%s is %w", name, ErrInvalidLockerType)
}

// MustParseLockerType converts a string to a LockerType, and panics if is not valid.
func MustParseLockerType(name string) LockerType {
	val, err := ParseLockerType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errLockerTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *LockerType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = LockerType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseLockerType(v)
	case []byte:
		*x, err = ParseLockerType(string(v))
	case LockerType:
		*x = v
	case *LockerType:
		if v == nil {
			return errLockerTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errLockerTypeNilPtr
		}
		*x, err = ParseLockerType(*v)
	default:
		return errors.New("invalid type for LockerType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x LockerType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// LogLevelTrace is a LogLevel of type trace.
	LogLevelTrace LogLevel = "trace"
	// LogLevelDebug is a LogLevel of type debug.
	LogLevelDebug LogLevel = "debug"
	// LogLevelInfo is a LogLevel of type info.
	LogLevelInfo LogLevel = "info"
	// LogLevelWarn is a LogLevel of type warn.
	LogLevelWarn LogLevel = "warn"
	// LogLevelError is a LogLevel of type error.
	LogLevelError LogLevel = "error"
	// LogLevelFatal is a LogLevel of type fatal.
	LogLevelFatal LogLevel = "fatal"
	// LogLevelPanic is a LogLevel of type panic.
	LogLevelPanic LogLevel = "panic"
)

var ErrInvalidLogLevel = errors.New("not a valid LogLevel")

// String implements the Stringer interface.
func (x LogLevel) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LogLevel) IsValid() bool {
	_, err := ParseLogLevel(string(x))
	return err == nil
}

var _LogLevelValue = map[string]LogLevel{
	"trace": LogLevelTrace,
	"debug": LogLevelDebug,
	"info":  LogLevelInfo,
	"warn":  LogLevelWarn,
	"error": LogLevelError,
	"fatal": LogLevelFatal,
	"panic": LogLevelPanic,
}

// ParseLogLevel attempts to convert a string to a LogLevel.
func ParseLogLevel(name string) (LogLevel, error) {
	if x, ok := _LogLevelValue[name]; ok {
		return x, nil
	}
	return LogLevel(""), fmt.Errorf("%s is %w", name, ErrInvalidLogLevel)
}

// MustParseLogLevel converts a string to a LogLevel, and panics if is not valid.
func MustParseLogLevel(name string) LogLevel {
	val, err := ParseLogLevel(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errLogLevelNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *LogLevel) Scan(value interface{}) (err error) {
	if value == nil {
		*x = LogLevel("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseLogLevel(v)
	case []byte:
		*x, err = ParseLogLevel(string(v))
	case LogLevel:
		*x = v
	case *LogLevel:
		if v == nil {
			return errLogLevelNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errLogLevelNilPtr
		}
		*x, err = ParseLogLevel(*v)
	default:
		return errors.New("invalid type for LogLevel")
	}

	return
}

// Value implements the driver Valuer interface.
func (x LogLevel) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// NamespaceRoleAdmin is a NamespaceRole of type Admin.
	NamespaceRoleAdmin NamespaceRole = "NamespaceAdmin"
	// NamespaceRoleManager is a NamespaceRole of type Manager.
	NamespaceRoleManager NamespaceRole = "namespace_manager"
	// NamespaceRoleReader is a NamespaceRole of type Reader.
	NamespaceRoleReader NamespaceRole = "NamespaceReader"
)

var ErrInvalidNamespaceRole = errors.New("not a valid NamespaceRole")

// String implements the Stringer interface.
func (x NamespaceRole) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x NamespaceRole) IsValid() bool {
	_, err := ParseNamespaceRole(string(x))
	return err == nil
}

var _NamespaceRoleValue = map[string]NamespaceRole{
	"NamespaceAdmin":    NamespaceRoleAdmin,
	"namespace_manager": NamespaceRoleManager,
	"NamespaceReader":   NamespaceRoleReader,
}

// ParseNamespaceRole attempts to convert a string to a NamespaceRole.
func ParseNamespaceRole(name string) (NamespaceRole, error) {
	if x, ok := _NamespaceRoleValue[name]; ok {
		return x, nil
	}
	return NamespaceRole(""), fmt.Errorf("%s is %w", name, ErrInvalidNamespaceRole)
}

// MustParseNamespaceRole converts a string to a NamespaceRole, and panics if is not valid.
func MustParseNamespaceRole(name string) NamespaceRole {
	val, err := ParseNamespaceRole(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errNamespaceRoleNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *NamespaceRole) Scan(value interface{}) (err error) {
	if value == nil {
		*x = NamespaceRole("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseNamespaceRole(v)
	case []byte:
		*x, err = ParseNamespaceRole(string(v))
	case NamespaceRole:
		*x = v
	case *NamespaceRole:
		if v == nil {
			return errNamespaceRoleNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errNamespaceRoleNilPtr
		}
		*x, err = ParseNamespaceRole(*v)
	default:
		return errors.New("invalid type for NamespaceRole")
	}

	return
}

// Value implements the driver Valuer interface.
func (x NamespaceRole) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// OciPlatformLinuxAmd64 is a OciPlatform of type linux/amd64.
	OciPlatformLinuxAmd64 OciPlatform = "linux/amd64"
	// OciPlatformLinuxAmd64V2 is a OciPlatform of type linux/amd64/v2.
	OciPlatformLinuxAmd64V2 OciPlatform = "linux/amd64/v2"
	// OciPlatformLinuxAmd64V3 is a OciPlatform of type linux/amd64/v3.
	OciPlatformLinuxAmd64V3 OciPlatform = "linux/amd64/v3"
	// OciPlatformLinuxArm64 is a OciPlatform of type linux/arm64.
	OciPlatformLinuxArm64 OciPlatform = "linux/arm64"
	// OciPlatformLinuxRiscv64 is a OciPlatform of type linux/riscv64.
	OciPlatformLinuxRiscv64 OciPlatform = "linux/riscv64"
	// OciPlatformLinuxPpc64le is a OciPlatform of type linux/ppc64le.
	OciPlatformLinuxPpc64le OciPlatform = "linux/ppc64le"
	// OciPlatformLinuxS390x is a OciPlatform of type linux/s390x.
	OciPlatformLinuxS390x OciPlatform = "linux/s390x"
	// OciPlatformLinux386 is a OciPlatform of type linux/386.
	OciPlatformLinux386 OciPlatform = "linux/386"
	// OciPlatformLinuxMips64le is a OciPlatform of type linux/mips64le.
	OciPlatformLinuxMips64le OciPlatform = "linux/mips64le"
	// OciPlatformLinuxMips64 is a OciPlatform of type linux/mips64.
	OciPlatformLinuxMips64 OciPlatform = "linux/mips64"
	// OciPlatformLinuxArmV7 is a OciPlatform of type linux/arm/v7.
	OciPlatformLinuxArmV7 OciPlatform = "linux/arm/v7"
	// OciPlatformLinuxArmV6 is a OciPlatform of type linux/arm/v6.
	OciPlatformLinuxArmV6 OciPlatform = "linux/arm/v6"
)

var ErrInvalidOciPlatform = errors.New("not a valid OciPlatform")

// String implements the Stringer interface.
func (x OciPlatform) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x OciPlatform) IsValid() bool {
	_, err := ParseOciPlatform(string(x))
	return err == nil
}

var _OciPlatformValue = map[string]OciPlatform{
	"linux/amd64":    OciPlatformLinuxAmd64,
	"linux/amd64/v2": OciPlatformLinuxAmd64V2,
	"linux/amd64/v3": OciPlatformLinuxAmd64V3,
	"linux/arm64":    OciPlatformLinuxArm64,
	"linux/riscv64":  OciPlatformLinuxRiscv64,
	"linux/ppc64le":  OciPlatformLinuxPpc64le,
	"linux/s390x":    OciPlatformLinuxS390x,
	"linux/386":      OciPlatformLinux386,
	"linux/mips64le": OciPlatformLinuxMips64le,
	"linux/mips64":   OciPlatformLinuxMips64,
	"linux/arm/v7":   OciPlatformLinuxArmV7,
	"linux/arm/v6":   OciPlatformLinuxArmV6,
}

// ParseOciPlatform attempts to convert a string to a OciPlatform.
func ParseOciPlatform(name string) (OciPlatform, error) {
	if x, ok := _OciPlatformValue[name]; ok {
		return x, nil
	}
	return OciPlatform(""), fmt.Errorf("%s is %w", name, ErrInvalidOciPlatform)
}

// MustParseOciPlatform converts a string to a OciPlatform, and panics if is not valid.
func MustParseOciPlatform(name string) OciPlatform {
	val, err := ParseOciPlatform(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errOciPlatformNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *OciPlatform) Scan(value interface{}) (err error) {
	if value == nil {
		*x = OciPlatform("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseOciPlatform(v)
	case []byte:
		*x, err = ParseOciPlatform(string(v))
	case OciPlatform:
		*x = v
	case *OciPlatform:
		if v == nil {
			return errOciPlatformNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errOciPlatformNilPtr
		}
		*x, err = ParseOciPlatform(*v)
	default:
		return errors.New("invalid type for OciPlatform")
	}

	return
}

// Value implements the driver Valuer interface.
func (x OciPlatform) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// OperateTypeManual is a OperateType of type Manual.
	OperateTypeManual OperateType = "Manual"
	// OperateTypeAutomatic is a OperateType of type Automatic.
	OperateTypeAutomatic OperateType = "Automatic"
)

var ErrInvalidOperateType = errors.New("not a valid OperateType")

// String implements the Stringer interface.
func (x OperateType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x OperateType) IsValid() bool {
	_, err := ParseOperateType(string(x))
	return err == nil
}

var _OperateTypeValue = map[string]OperateType{
	"Manual":    OperateTypeManual,
	"Automatic": OperateTypeAutomatic,
}

// ParseOperateType attempts to convert a string to a OperateType.
func ParseOperateType(name string) (OperateType, error) {
	if x, ok := _OperateTypeValue[name]; ok {
		return x, nil
	}
	return OperateType(""), fmt.Errorf("%s is %w", name, ErrInvalidOperateType)
}

// MustParseOperateType converts a string to a OperateType, and panics if is not valid.
func MustParseOperateType(name string) OperateType {
	val, err := ParseOperateType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errOperateTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *OperateType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = OperateType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseOperateType(v)
	case []byte:
		*x, err = ParseOperateType(string(v))
	case OperateType:
		*x = v
	case *OperateType:
		if v == nil {
			return errOperateTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errOperateTypeNilPtr
		}
		*x, err = ParseOperateType(*v)
	default:
		return errors.New("invalid type for OperateType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x OperateType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// ProviderLocal is a Provider of type local.
	ProviderLocal Provider = "local"
	// ProviderGithub is a Provider of type github.
	ProviderGithub Provider = "github"
	// ProviderGitlab is a Provider of type gitlab.
	ProviderGitlab Provider = "gitlab"
	// ProviderGitea is a Provider of type gitea.
	ProviderGitea Provider = "gitea"
)

var ErrInvalidProvider = errors.New("not a valid Provider")

// String implements the Stringer interface.
func (x Provider) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Provider) IsValid() bool {
	_, err := ParseProvider(string(x))
	return err == nil
}

var _ProviderValue = map[string]Provider{
	"local":  ProviderLocal,
	"github": ProviderGithub,
	"gitlab": ProviderGitlab,
	"gitea":  ProviderGitea,
}

// ParseProvider attempts to convert a string to a Provider.
func ParseProvider(name string) (Provider, error) {
	if x, ok := _ProviderValue[name]; ok {
		return x, nil
	}
	return Provider(""), fmt.Errorf("%s is %w", name, ErrInvalidProvider)
}

// MustParseProvider converts a string to a Provider, and panics if is not valid.
func MustParseProvider(name string) Provider {
	val, err := ParseProvider(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errProviderNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Provider) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Provider("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseProvider(v)
	case []byte:
		*x, err = ParseProvider(string(v))
	case Provider:
		*x = v
	case *Provider:
		if v == nil {
			return errProviderNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errProviderNilPtr
		}
		*x, err = ParseProvider(*v)
	default:
		return errors.New("invalid type for Provider")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Provider) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// RedisTypeNone is a RedisType of type none.
	RedisTypeNone RedisType = "none"
	// RedisTypeExternal is a RedisType of type external.
	RedisTypeExternal RedisType = "external"
)

var ErrInvalidRedisType = errors.New("not a valid RedisType")

// String implements the Stringer interface.
func (x RedisType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x RedisType) IsValid() bool {
	_, err := ParseRedisType(string(x))
	return err == nil
}

var _RedisTypeValue = map[string]RedisType{
	"none":     RedisTypeNone,
	"external": RedisTypeExternal,
}

// ParseRedisType attempts to convert a string to a RedisType.
func ParseRedisType(name string) (RedisType, error) {
	if x, ok := _RedisTypeValue[name]; ok {
		return x, nil
	}
	return RedisType(""), fmt.Errorf("%s is %w", name, ErrInvalidRedisType)
}

// MustParseRedisType converts a string to a RedisType, and panics if is not valid.
func MustParseRedisType(name string) RedisType {
	val, err := ParseRedisType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errRedisTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *RedisType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = RedisType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseRedisType(v)
	case []byte:
		*x, err = ParseRedisType(string(v))
	case RedisType:
		*x = v
	case *RedisType:
		if v == nil {
			return errRedisTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errRedisTypeNilPtr
		}
		*x, err = ParseRedisType(*v)
	default:
		return errors.New("invalid type for RedisType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x RedisType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// RetentionRuleTypeDay is a RetentionRuleType of type Day.
	RetentionRuleTypeDay RetentionRuleType = "Day"
	// RetentionRuleTypeQuantity is a RetentionRuleType of type Quantity.
	RetentionRuleTypeQuantity RetentionRuleType = "Quantity"
)

var ErrInvalidRetentionRuleType = errors.New("not a valid RetentionRuleType")

// String implements the Stringer interface.
func (x RetentionRuleType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x RetentionRuleType) IsValid() bool {
	_, err := ParseRetentionRuleType(string(x))
	return err == nil
}

var _RetentionRuleTypeValue = map[string]RetentionRuleType{
	"Day":      RetentionRuleTypeDay,
	"Quantity": RetentionRuleTypeQuantity,
}

// ParseRetentionRuleType attempts to convert a string to a RetentionRuleType.
func ParseRetentionRuleType(name string) (RetentionRuleType, error) {
	if x, ok := _RetentionRuleTypeValue[name]; ok {
		return x, nil
	}
	return RetentionRuleType(""), fmt.Errorf("%s is %w", name, ErrInvalidRetentionRuleType)
}

// MustParseRetentionRuleType converts a string to a RetentionRuleType, and panics if is not valid.
func MustParseRetentionRuleType(name string) RetentionRuleType {
	val, err := ParseRetentionRuleType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errRetentionRuleTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *RetentionRuleType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = RetentionRuleType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseRetentionRuleType(v)
	case []byte:
		*x, err = ParseRetentionRuleType(string(v))
	case RetentionRuleType:
		*x = v
	case *RetentionRuleType:
		if v == nil {
			return errRetentionRuleTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errRetentionRuleTypeNilPtr
		}
		*x, err = ParseRetentionRuleType(*v)
	default:
		return errors.New("invalid type for RetentionRuleType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x RetentionRuleType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// ScmCredentialTypeSsh is a ScmCredentialType of type ssh.
	ScmCredentialTypeSsh ScmCredentialType = "ssh"
	// ScmCredentialTypeToken is a ScmCredentialType of type token.
	ScmCredentialTypeToken ScmCredentialType = "token"
	// ScmCredentialTypeUsername is a ScmCredentialType of type username.
	ScmCredentialTypeUsername ScmCredentialType = "username"
	// ScmCredentialTypeNone is a ScmCredentialType of type none.
	ScmCredentialTypeNone ScmCredentialType = "none"
)

var ErrInvalidScmCredentialType = errors.New("not a valid ScmCredentialType")

// String implements the Stringer interface.
func (x ScmCredentialType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ScmCredentialType) IsValid() bool {
	_, err := ParseScmCredentialType(string(x))
	return err == nil
}

var _ScmCredentialTypeValue = map[string]ScmCredentialType{
	"ssh":      ScmCredentialTypeSsh,
	"token":    ScmCredentialTypeToken,
	"username": ScmCredentialTypeUsername,
	"none":     ScmCredentialTypeNone,
}

// ParseScmCredentialType attempts to convert a string to a ScmCredentialType.
func ParseScmCredentialType(name string) (ScmCredentialType, error) {
	if x, ok := _ScmCredentialTypeValue[name]; ok {
		return x, nil
	}
	return ScmCredentialType(""), fmt.Errorf("%s is %w", name, ErrInvalidScmCredentialType)
}

// MustParseScmCredentialType converts a string to a ScmCredentialType, and panics if is not valid.
func MustParseScmCredentialType(name string) ScmCredentialType {
	val, err := ParseScmCredentialType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errScmCredentialTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ScmCredentialType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ScmCredentialType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseScmCredentialType(v)
	case []byte:
		*x, err = ParseScmCredentialType(string(v))
	case ScmCredentialType:
		*x = v
	case *ScmCredentialType:
		if v == nil {
			return errScmCredentialTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errScmCredentialTypeNilPtr
		}
		*x, err = ParseScmCredentialType(*v)
	default:
		return errors.New("invalid type for ScmCredentialType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x ScmCredentialType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// ScmProviderGithub is a ScmProvider of type github.
	ScmProviderGithub ScmProvider = "github"
	// ScmProviderGitlab is a ScmProvider of type gitlab.
	ScmProviderGitlab ScmProvider = "gitlab"
	// ScmProviderGitea is a ScmProvider of type gitea.
	ScmProviderGitea ScmProvider = "gitea"
	// ScmProviderNone is a ScmProvider of type none.
	ScmProviderNone ScmProvider = "none"
)

var ErrInvalidScmProvider = errors.New("not a valid ScmProvider")

// String implements the Stringer interface.
func (x ScmProvider) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ScmProvider) IsValid() bool {
	_, err := ParseScmProvider(string(x))
	return err == nil
}

var _ScmProviderValue = map[string]ScmProvider{
	"github": ScmProviderGithub,
	"gitlab": ScmProviderGitlab,
	"gitea":  ScmProviderGitea,
	"none":   ScmProviderNone,
}

// ParseScmProvider attempts to convert a string to a ScmProvider.
func ParseScmProvider(name string) (ScmProvider, error) {
	if x, ok := _ScmProviderValue[name]; ok {
		return x, nil
	}
	return ScmProvider(""), fmt.Errorf("%s is %w", name, ErrInvalidScmProvider)
}

// MustParseScmProvider converts a string to a ScmProvider, and panics if is not valid.
func MustParseScmProvider(name string) ScmProvider {
	val, err := ParseScmProvider(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errScmProviderNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ScmProvider) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ScmProvider("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseScmProvider(v)
	case []byte:
		*x, err = ParseScmProvider(string(v))
	case ScmProvider:
		*x = v
	case *ScmProvider:
		if v == nil {
			return errScmProviderNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errScmProviderNilPtr
		}
		*x, err = ParseScmProvider(*v)
	default:
		return errors.New("invalid type for ScmProvider")
	}

	return
}

// Value implements the driver Valuer interface.
func (x ScmProvider) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// SigningTypeCosign is a SigningType of type cosign.
	SigningTypeCosign SigningType = "cosign"
)

var ErrInvalidSigningType = errors.New("not a valid SigningType")

// String implements the Stringer interface.
func (x SigningType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SigningType) IsValid() bool {
	_, err := ParseSigningType(string(x))
	return err == nil
}

var _SigningTypeValue = map[string]SigningType{
	"cosign": SigningTypeCosign,
}

// ParseSigningType attempts to convert a string to a SigningType.
func ParseSigningType(name string) (SigningType, error) {
	if x, ok := _SigningTypeValue[name]; ok {
		return x, nil
	}
	return SigningType(""), fmt.Errorf("%s is %w", name, ErrInvalidSigningType)
}

// MustParseSigningType converts a string to a SigningType, and panics if is not valid.
func MustParseSigningType(name string) SigningType {
	val, err := ParseSigningType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errSigningTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *SigningType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = SigningType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseSigningType(v)
	case []byte:
		*x, err = ParseSigningType(string(v))
	case SigningType:
		*x = v
	case *SigningType:
		if v == nil {
			return errSigningTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errSigningTypeNilPtr
		}
		*x, err = ParseSigningType(*v)
	default:
		return errors.New("invalid type for SigningType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x SigningType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// SortMethodAsc is a SortMethod of type asc.
	SortMethodAsc SortMethod = "asc"
	// SortMethodDesc is a SortMethod of type desc.
	SortMethodDesc SortMethod = "desc"
)

var ErrInvalidSortMethod = errors.New("not a valid SortMethod")

// String implements the Stringer interface.
func (x SortMethod) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SortMethod) IsValid() bool {
	_, err := ParseSortMethod(string(x))
	return err == nil
}

var _SortMethodValue = map[string]SortMethod{
	"asc":  SortMethodAsc,
	"desc": SortMethodDesc,
}

// ParseSortMethod attempts to convert a string to a SortMethod.
func ParseSortMethod(name string) (SortMethod, error) {
	if x, ok := _SortMethodValue[name]; ok {
		return x, nil
	}
	return SortMethod(""), fmt.Errorf("%s is %w", name, ErrInvalidSortMethod)
}

// MustParseSortMethod converts a string to a SortMethod, and panics if is not valid.
func MustParseSortMethod(name string) SortMethod {
	val, err := ParseSortMethod(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errSortMethodNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *SortMethod) Scan(value interface{}) (err error) {
	if value == nil {
		*x = SortMethod("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseSortMethod(v)
	case []byte:
		*x, err = ParseSortMethod(string(v))
	case SortMethod:
		*x = v
	case *SortMethod:
		if v == nil {
			return errSortMethodNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errSortMethodNilPtr
		}
		*x, err = ParseSortMethod(*v)
	default:
		return errors.New("invalid type for SortMethod")
	}

	return
}

// Value implements the driver Valuer interface.
func (x SortMethod) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// StorageTypeS3 is a StorageType of type s3.
	StorageTypeS3 StorageType = "s3"
	// StorageTypeFilesystem is a StorageType of type filesystem.
	StorageTypeFilesystem StorageType = "filesystem"
	// StorageTypeCos is a StorageType of type cos.
	StorageTypeCos StorageType = "cos"
	// StorageTypeOss is a StorageType of type oss.
	StorageTypeOss StorageType = "oss"
	// StorageTypeDummy is a StorageType of type dummy.
	StorageTypeDummy StorageType = "dummy"
)

var ErrInvalidStorageType = errors.New("not a valid StorageType")

// String implements the Stringer interface.
func (x StorageType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x StorageType) IsValid() bool {
	_, err := ParseStorageType(string(x))
	return err == nil
}

var _StorageTypeValue = map[string]StorageType{
	"s3":         StorageTypeS3,
	"filesystem": StorageTypeFilesystem,
	"cos":        StorageTypeCos,
	"oss":        StorageTypeOss,
	"dummy":      StorageTypeDummy,
}

// ParseStorageType attempts to convert a string to a StorageType.
func ParseStorageType(name string) (StorageType, error) {
	if x, ok := _StorageTypeValue[name]; ok {
		return x, nil
	}
	return StorageType(""), fmt.Errorf("%s is %w", name, ErrInvalidStorageType)
}

// MustParseStorageType converts a string to a StorageType, and panics if is not valid.
func MustParseStorageType(name string) StorageType {
	val, err := ParseStorageType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errStorageTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *StorageType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = StorageType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseStorageType(v)
	case []byte:
		*x, err = ParseStorageType(string(v))
	case StorageType:
		*x = v
	case *StorageType:
		if v == nil {
			return errStorageTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errStorageTypeNilPtr
		}
		*x, err = ParseStorageType(*v)
	default:
		return errors.New("invalid type for StorageType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x StorageType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// TaskCommonStatusPending is a TaskCommonStatus of type Pending.
	TaskCommonStatusPending TaskCommonStatus = "Pending"
	// TaskCommonStatusDoing is a TaskCommonStatus of type Doing.
	TaskCommonStatusDoing TaskCommonStatus = "Doing"
	// TaskCommonStatusSuccess is a TaskCommonStatus of type Success.
	TaskCommonStatusSuccess TaskCommonStatus = "Success"
	// TaskCommonStatusFailed is a TaskCommonStatus of type Failed.
	TaskCommonStatusFailed TaskCommonStatus = "Failed"
)

var ErrInvalidTaskCommonStatus = errors.New("not a valid TaskCommonStatus")

// String implements the Stringer interface.
func (x TaskCommonStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TaskCommonStatus) IsValid() bool {
	_, err := ParseTaskCommonStatus(string(x))
	return err == nil
}

var _TaskCommonStatusValue = map[string]TaskCommonStatus{
	"Pending": TaskCommonStatusPending,
	"Doing":   TaskCommonStatusDoing,
	"Success": TaskCommonStatusSuccess,
	"Failed":  TaskCommonStatusFailed,
}

// ParseTaskCommonStatus attempts to convert a string to a TaskCommonStatus.
func ParseTaskCommonStatus(name string) (TaskCommonStatus, error) {
	if x, ok := _TaskCommonStatusValue[name]; ok {
		return x, nil
	}
	return TaskCommonStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidTaskCommonStatus)
}

// MustParseTaskCommonStatus converts a string to a TaskCommonStatus, and panics if is not valid.
func MustParseTaskCommonStatus(name string) TaskCommonStatus {
	val, err := ParseTaskCommonStatus(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errTaskCommonStatusNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *TaskCommonStatus) Scan(value interface{}) (err error) {
	if value == nil {
		*x = TaskCommonStatus("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseTaskCommonStatus(v)
	case []byte:
		*x, err = ParseTaskCommonStatus(string(v))
	case TaskCommonStatus:
		*x = v
	case *TaskCommonStatus:
		if v == nil {
			return errTaskCommonStatusNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errTaskCommonStatusNilPtr
		}
		*x, err = ParseTaskCommonStatus(*v)
	default:
		return errors.New("invalid type for TaskCommonStatus")
	}

	return
}

// Value implements the driver Valuer interface.
func (x TaskCommonStatus) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// UserRoleRoot is a UserRole of type Root.
	UserRoleRoot UserRole = "Root"
	// UserRoleAdmin is a UserRole of type Admin.
	UserRoleAdmin UserRole = "Admin"
	// UserRoleUser is a UserRole of type User.
	UserRoleUser UserRole = "User"
	// UserRoleAnonymous is a UserRole of type Anonymous.
	UserRoleAnonymous UserRole = "Anonymous"
)

var ErrInvalidUserRole = errors.New("not a valid UserRole")

// String implements the Stringer interface.
func (x UserRole) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UserRole) IsValid() bool {
	_, err := ParseUserRole(string(x))
	return err == nil
}

var _UserRoleValue = map[string]UserRole{
	"Root":      UserRoleRoot,
	"Admin":     UserRoleAdmin,
	"User":      UserRoleUser,
	"Anonymous": UserRoleAnonymous,
}

// ParseUserRole attempts to convert a string to a UserRole.
func ParseUserRole(name string) (UserRole, error) {
	if x, ok := _UserRoleValue[name]; ok {
		return x, nil
	}
	return UserRole(""), fmt.Errorf("%s is %w", name, ErrInvalidUserRole)
}

// MustParseUserRole converts a string to a UserRole, and panics if is not valid.
func MustParseUserRole(name string) UserRole {
	val, err := ParseUserRole(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errUserRoleNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *UserRole) Scan(value interface{}) (err error) {
	if value == nil {
		*x = UserRole("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseUserRole(v)
	case []byte:
		*x, err = ParseUserRole(string(v))
	case UserRole:
		*x = v
	case *UserRole:
		if v == nil {
			return errUserRoleNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errUserRoleNilPtr
		}
		*x, err = ParseUserRole(*v)
	default:
		return errors.New("invalid type for UserRole")
	}

	return
}

// Value implements the driver Valuer interface.
func (x UserRole) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// UserStatusActive is a UserStatus of type Active.
	UserStatusActive UserStatus = "Active"
	// UserStatusInactive is a UserStatus of type Inactive.
	UserStatusInactive UserStatus = "Inactive"
)

var ErrInvalidUserStatus = errors.New("not a valid UserStatus")

// String implements the Stringer interface.
func (x UserStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UserStatus) IsValid() bool {
	_, err := ParseUserStatus(string(x))
	return err == nil
}

var _UserStatusValue = map[string]UserStatus{
	"Active":   UserStatusActive,
	"Inactive": UserStatusInactive,
}

// ParseUserStatus attempts to convert a string to a UserStatus.
func ParseUserStatus(name string) (UserStatus, error) {
	if x, ok := _UserStatusValue[name]; ok {
		return x, nil
	}
	return UserStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidUserStatus)
}

// MustParseUserStatus converts a string to a UserStatus, and panics if is not valid.
func MustParseUserStatus(name string) UserStatus {
	val, err := ParseUserStatus(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errUserStatusNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *UserStatus) Scan(value interface{}) (err error) {
	if value == nil {
		*x = UserStatus("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseUserStatus(v)
	case []byte:
		*x, err = ParseUserStatus(string(v))
	case UserStatus:
		*x = v
	case *UserStatus:
		if v == nil {
			return errUserStatusNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errUserStatusNilPtr
		}
		*x, err = ParseUserStatus(*v)
	default:
		return errors.New("invalid type for UserStatus")
	}

	return
}

// Value implements the driver Valuer interface.
func (x UserStatus) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// VisibilityPrivate is a Visibility of type private.
	VisibilityPrivate Visibility = "private"
	// VisibilityPublic is a Visibility of type public.
	VisibilityPublic Visibility = "public"
)

var ErrInvalidVisibility = errors.New("not a valid Visibility")

// String implements the Stringer interface.
func (x Visibility) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Visibility) IsValid() bool {
	_, err := ParseVisibility(string(x))
	return err == nil
}

var _VisibilityValue = map[string]Visibility{
	"private": VisibilityPrivate,
	"public":  VisibilityPublic,
}

// ParseVisibility attempts to convert a string to a Visibility.
func ParseVisibility(name string) (Visibility, error) {
	if x, ok := _VisibilityValue[name]; ok {
		return x, nil
	}
	return Visibility(""), fmt.Errorf("%s is %w", name, ErrInvalidVisibility)
}

// MustParseVisibility converts a string to a Visibility, and panics if is not valid.
func MustParseVisibility(name string) Visibility {
	val, err := ParseVisibility(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errVisibilityNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Visibility) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Visibility("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseVisibility(v)
	case []byte:
		*x, err = ParseVisibility(string(v))
	case Visibility:
		*x = v
	case *Visibility:
		if v == nil {
			return errVisibilityNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errVisibilityNilPtr
		}
		*x, err = ParseVisibility(*v)
	default:
		return errors.New("invalid type for Visibility")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Visibility) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// WebhookActionCreate is a WebhookAction of type Create.
	WebhookActionCreate WebhookAction = "Create"
	// WebhookActionUpdate is a WebhookAction of type Update.
	WebhookActionUpdate WebhookAction = "Update"
	// WebhookActionDelete is a WebhookAction of type Delete.
	WebhookActionDelete WebhookAction = "Delete"
	// WebhookActionAdd is a WebhookAction of type Add.
	WebhookActionAdd WebhookAction = "Add"
	// WebhookActionRemove is a WebhookAction of type Remove.
	WebhookActionRemove WebhookAction = "Remove"
	// WebhookActionPing is a WebhookAction of type Ping.
	WebhookActionPing WebhookAction = "Ping"
	// WebhookActionStarted is a WebhookAction of type Started.
	WebhookActionStarted WebhookAction = "Started"
	// WebhookActionDoing is a WebhookAction of type Doing.
	WebhookActionDoing WebhookAction = "Doing"
	// WebhookActionFinished is a WebhookAction of type Finished.
	WebhookActionFinished WebhookAction = "Finished"
)

var ErrInvalidWebhookAction = errors.New("not a valid WebhookAction")

// String implements the Stringer interface.
func (x WebhookAction) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x WebhookAction) IsValid() bool {
	_, err := ParseWebhookAction(string(x))
	return err == nil
}

var _WebhookActionValue = map[string]WebhookAction{
	"Create":   WebhookActionCreate,
	"Update":   WebhookActionUpdate,
	"Delete":   WebhookActionDelete,
	"Add":      WebhookActionAdd,
	"Remove":   WebhookActionRemove,
	"Ping":     WebhookActionPing,
	"Started":  WebhookActionStarted,
	"Doing":    WebhookActionDoing,
	"Finished": WebhookActionFinished,
}

// ParseWebhookAction attempts to convert a string to a WebhookAction.
func ParseWebhookAction(name string) (WebhookAction, error) {
	if x, ok := _WebhookActionValue[name]; ok {
		return x, nil
	}
	return WebhookAction(""), fmt.Errorf("%s is %w", name, ErrInvalidWebhookAction)
}

// MustParseWebhookAction converts a string to a WebhookAction, and panics if is not valid.
func MustParseWebhookAction(name string) WebhookAction {
	val, err := ParseWebhookAction(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errWebhookActionNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *WebhookAction) Scan(value interface{}) (err error) {
	if value == nil {
		*x = WebhookAction("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseWebhookAction(v)
	case []byte:
		*x, err = ParseWebhookAction(string(v))
	case WebhookAction:
		*x = v
	case *WebhookAction:
		if v == nil {
			return errWebhookActionNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errWebhookActionNilPtr
		}
		*x, err = ParseWebhookAction(*v)
	default:
		return errors.New("invalid type for WebhookAction")
	}

	return
}

// Value implements the driver Valuer interface.
func (x WebhookAction) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// WebhookResourceTypeWebhook is a WebhookResourceType of type Webhook.
	WebhookResourceTypeWebhook WebhookResourceType = "Webhook"
	// WebhookResourceTypeNamespace is a WebhookResourceType of type Namespace.
	WebhookResourceTypeNamespace WebhookResourceType = "Namespace"
	// WebhookResourceTypeRepository is a WebhookResourceType of type Repository.
	WebhookResourceTypeRepository WebhookResourceType = "Repository"
	// WebhookResourceTypeTag is a WebhookResourceType of type Tag.
	WebhookResourceTypeTag WebhookResourceType = "Tag"
	// WebhookResourceTypeArtifact is a WebhookResourceType of type Artifact.
	WebhookResourceTypeArtifact WebhookResourceType = "Artifact"
	// WebhookResourceTypeMember is a WebhookResourceType of type Member.
	WebhookResourceTypeMember WebhookResourceType = "Member"
	// WebhookResourceTypeDaemonTaskGcRepositoryRule is a WebhookResourceType of type DaemonTaskGcRepositoryRule.
	WebhookResourceTypeDaemonTaskGcRepositoryRule WebhookResourceType = "DaemonTaskGcRepositoryRule"
	// WebhookResourceTypeDaemonTaskGcTagRule is a WebhookResourceType of type DaemonTaskGcTagRule.
	WebhookResourceTypeDaemonTaskGcTagRule WebhookResourceType = "DaemonTaskGcTagRule"
	// WebhookResourceTypeDaemonTaskGcArtifactRule is a WebhookResourceType of type DaemonTaskGcArtifactRule.
	WebhookResourceTypeDaemonTaskGcArtifactRule WebhookResourceType = "DaemonTaskGcArtifactRule"
	// WebhookResourceTypeDaemonTaskGcBlobRule is a WebhookResourceType of type DaemonTaskGcBlobRule.
	WebhookResourceTypeDaemonTaskGcBlobRule WebhookResourceType = "DaemonTaskGcBlobRule"
	// WebhookResourceTypeDaemonTaskGcRepositoryRunner is a WebhookResourceType of type DaemonTaskGcRepositoryRunner.
	WebhookResourceTypeDaemonTaskGcRepositoryRunner WebhookResourceType = "DaemonTaskGcRepositoryRunner"
	// WebhookResourceTypeDaemonTaskGcTagRunner is a WebhookResourceType of type DaemonTaskGcTagRunner.
	WebhookResourceTypeDaemonTaskGcTagRunner WebhookResourceType = "DaemonTaskGcTagRunner"
	// WebhookResourceTypeDaemonTaskGcArtifactRunner is a WebhookResourceType of type DaemonTaskGcArtifactRunner.
	WebhookResourceTypeDaemonTaskGcArtifactRunner WebhookResourceType = "DaemonTaskGcArtifactRunner"
	// WebhookResourceTypeDaemonTaskGcBlobRunner is a WebhookResourceType of type DaemonTaskGcBlobRunner.
	WebhookResourceTypeDaemonTaskGcBlobRunner WebhookResourceType = "DaemonTaskGcBlobRunner"
)

var ErrInvalidWebhookResourceType = errors.New("not a valid WebhookResourceType")

// String implements the Stringer interface.
func (x WebhookResourceType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x WebhookResourceType) IsValid() bool {
	_, err := ParseWebhookResourceType(string(x))
	return err == nil
}

var _WebhookResourceTypeValue = map[string]WebhookResourceType{
	"Webhook":                      WebhookResourceTypeWebhook,
	"Namespace":                    WebhookResourceTypeNamespace,
	"Repository":                   WebhookResourceTypeRepository,
	"Tag":                          WebhookResourceTypeTag,
	"Artifact":                     WebhookResourceTypeArtifact,
	"Member":                       WebhookResourceTypeMember,
	"DaemonTaskGcRepositoryRule":   WebhookResourceTypeDaemonTaskGcRepositoryRule,
	"DaemonTaskGcTagRule":          WebhookResourceTypeDaemonTaskGcTagRule,
	"DaemonTaskGcArtifactRule":     WebhookResourceTypeDaemonTaskGcArtifactRule,
	"DaemonTaskGcBlobRule":         WebhookResourceTypeDaemonTaskGcBlobRule,
	"DaemonTaskGcRepositoryRunner": WebhookResourceTypeDaemonTaskGcRepositoryRunner,
	"DaemonTaskGcTagRunner":        WebhookResourceTypeDaemonTaskGcTagRunner,
	"DaemonTaskGcArtifactRunner":   WebhookResourceTypeDaemonTaskGcArtifactRunner,
	"DaemonTaskGcBlobRunner":       WebhookResourceTypeDaemonTaskGcBlobRunner,
}

// ParseWebhookResourceType attempts to convert a string to a WebhookResourceType.
func ParseWebhookResourceType(name string) (WebhookResourceType, error) {
	if x, ok := _WebhookResourceTypeValue[name]; ok {
		return x, nil
	}
	return WebhookResourceType(""), fmt.Errorf("%s is %w", name, ErrInvalidWebhookResourceType)
}

// MustParseWebhookResourceType converts a string to a WebhookResourceType, and panics if is not valid.
func MustParseWebhookResourceType(name string) WebhookResourceType {
	val, err := ParseWebhookResourceType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errWebhookResourceTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *WebhookResourceType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = WebhookResourceType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseWebhookResourceType(v)
	case []byte:
		*x, err = ParseWebhookResourceType(string(v))
	case WebhookResourceType:
		*x = v
	case *WebhookResourceType:
		if v == nil {
			return errWebhookResourceTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errWebhookResourceTypeNilPtr
		}
		*x, err = ParseWebhookResourceType(*v)
	default:
		return errors.New("invalid type for WebhookResourceType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x WebhookResourceType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// WebhookTypePing is a WebhookType of type Ping.
	WebhookTypePing WebhookType = "Ping"
	// WebhookTypeSend is a WebhookType of type Send.
	WebhookTypeSend WebhookType = "Send"
	// WebhookTypeResend is a WebhookType of type Resend.
	WebhookTypeResend WebhookType = "Resend"
)

var ErrInvalidWebhookType = errors.New("not a valid WebhookType")

// String implements the Stringer interface.
func (x WebhookType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x WebhookType) IsValid() bool {
	_, err := ParseWebhookType(string(x))
	return err == nil
}

var _WebhookTypeValue = map[string]WebhookType{
	"Ping":   WebhookTypePing,
	"Send":   WebhookTypeSend,
	"Resend": WebhookTypeResend,
}

// ParseWebhookType attempts to convert a string to a WebhookType.
func ParseWebhookType(name string) (WebhookType, error) {
	if x, ok := _WebhookTypeValue[name]; ok {
		return x, nil
	}
	return WebhookType(""), fmt.Errorf("%s is %w", name, ErrInvalidWebhookType)
}

// MustParseWebhookType converts a string to a WebhookType, and panics if is not valid.
func MustParseWebhookType(name string) WebhookType {
	val, err := ParseWebhookType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errWebhookTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *WebhookType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = WebhookType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseWebhookType(v)
	case []byte:
		*x, err = ParseWebhookType(string(v))
	case WebhookType:
		*x = v
	case *WebhookType:
		if v == nil {
			return errWebhookTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errWebhookTypeNilPtr
		}
		*x, err = ParseWebhookType(*v)
	default:
		return errors.New("invalid type for WebhookType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x WebhookType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// WorkQueueTypeRedis is a WorkQueueType of type redis.
	WorkQueueTypeRedis WorkQueueType = "redis"
	// WorkQueueTypeKafka is a WorkQueueType of type kafka.
	WorkQueueTypeKafka WorkQueueType = "kafka"
	// WorkQueueTypeDatabase is a WorkQueueType of type database.
	WorkQueueTypeDatabase WorkQueueType = "database"
	// WorkQueueTypeInmemory is a WorkQueueType of type inmemory.
	WorkQueueTypeInmemory WorkQueueType = "inmemory"
)

var ErrInvalidWorkQueueType = errors.New("not a valid WorkQueueType")

// String implements the Stringer interface.
func (x WorkQueueType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x WorkQueueType) IsValid() bool {
	_, err := ParseWorkQueueType(string(x))
	return err == nil
}

var _WorkQueueTypeValue = map[string]WorkQueueType{
	"redis":    WorkQueueTypeRedis,
	"kafka":    WorkQueueTypeKafka,
	"database": WorkQueueTypeDatabase,
	"inmemory": WorkQueueTypeInmemory,
}

// ParseWorkQueueType attempts to convert a string to a WorkQueueType.
func ParseWorkQueueType(name string) (WorkQueueType, error) {
	if x, ok := _WorkQueueTypeValue[name]; ok {
		return x, nil
	}
	return WorkQueueType(""), fmt.Errorf("%s is %w", name, ErrInvalidWorkQueueType)
}

// MustParseWorkQueueType converts a string to a WorkQueueType, and panics if is not valid.
func MustParseWorkQueueType(name string) WorkQueueType {
	val, err := ParseWorkQueueType(name)
	if err != nil {
		panic(err)
	}
	return val
}

var errWorkQueueTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *WorkQueueType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = WorkQueueType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseWorkQueueType(v)
	case []byte:
		*x, err = ParseWorkQueueType(string(v))
	case WorkQueueType:
		*x = v
	case *WorkQueueType:
		if v == nil {
			return errWorkQueueTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errWorkQueueTypeNilPtr
		}
		*x, err = ParseWorkQueueType(*v)
	default:
		return errors.New("invalid type for WorkQueueType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x WorkQueueType) Value() (driver.Value, error) {
	return x.String(), nil
}
